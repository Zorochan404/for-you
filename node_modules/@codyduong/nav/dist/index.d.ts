import { UnionToIntersection } from 'type-fest';
declare type UnionForAny<T> = T extends never ? 'A' : 'B';
declare type IsStrictlyAny<T> = UnionToIntersection<UnionForAny<T>> extends never ? true : false;
declare type RemoveAnyFromObject<T extends Record<string, any>> = {
    [K in keyof T as IsStrictlyAny<T[K]> extends true ? never : K]: T[K];
};
declare type navNode<T, Surplus = never> = IsStrictlyAny<T> extends true ? any : T extends Array<infer Item> ? IsStrictlyAny<Item> extends true ? [number?] : [(number | Surplus)?, ...isNavNodeable<Item>] : T extends Record<infer Key, infer Item> ? IsStrictlyAny<Item> extends true ? navNode<RemoveAnyFromObject<T>, Key> extends never ? any[] : navNode<RemoveAnyFromObject<T>, Key> : {
    [K in keyof T]: [(K | Surplus)?, ...isNavNodeable<T[K]>];
}[keyof T] : [Surplus?];
declare type isNavNodeable<T> = T extends Array<any> ? navNode<T> : T extends Record<string, any> ? navNode<T> : [];
declare type RemoveFirstFromTuple<T extends any[]> = T['length'] extends 0 ? undefined : ((...b: T) => void) extends (a: any, ...b: infer I) => void ? I : [];
declare type isReturnNodeableAny<O extends Record<string, any> | Array<any> | ReadonlyArray<any> | never | undefined> = IsStrictlyAny<O> extends true ? true : O extends Array<infer AV> | Readonly<Array<infer AV>> ? IsStrictlyAny<AV> : false;
declare type IsRestEmpty<Rest> = Rest extends any[] ? RemoveFirstFromTuple<Rest> extends {
    length: 0;
} ? true : RemoveFirstFromTuple<Rest> extends undefined ? true : false : Exclude<Rest, undefined> extends never ? true : false;
declare type NonNullableExtended<O> = IsStrictlyAny<O> extends true ? never : O extends Record<string, any> | Readonly<Record<string, any>> ? {
    [K in keyof O]: NonNullable<O[K]>;
} : O extends Array<any> | ReadonlyArray<any> ? NonNullable<O> : NonNullable<O>;
export declare type navReturnNode<O extends Record<string, any> | Array<any> | never, Tuple extends ReadonlyArray<any> | undefined, Surplus extends Readonly<any> = never> = isReturnNodeableAny<O> extends true ? any : isReturnNodeableAny<Tuple> extends true ? any : Tuple extends [infer First, ...infer Rest] | Readonly<[infer First, ...infer Rest]> ? First extends keyof O ? Rest extends Array<any> | ReadonlyArray<any> ? navReturnNode<O[First], Rest, Surplus> : O[First] : undefined : Tuple extends [...infer Rest] | Readonly<[...infer Rest]> ? Rest extends Array<any> | ReadonlyArray<any> ? Exclude<Rest[0], undefined> extends keyof O ? IsRestEmpty<Rest> extends true ? NonNullableExtended<O> | NonNullableExtended<Surplus> : navReturnNode<O[Exclude<Rest[0], undefined>], RemoveFirstFromTuple<Rest>, O> : IsRestEmpty<Rest> extends true ? navReturnNode<NonNullableExtended<O> & UnionToIntersection<O>[Exclude<Rest[0], undefined>], RemoveFirstFromTuple<Rest>, O> : navReturnNode<UnionToIntersection<O>[Exclude<Rest[0], undefined>], RemoveFirstFromTuple<Rest>, O> : undefined : O | NonNullableExtended<Surplus>;
export declare function nav<R extends Record<string, any> | Array<any> | Readonly<Record<string, any>> | Readonly<Array<any>> = any, I extends Readonly<navNode<R>> = Readonly<navNode<R>>, D = any>(root: R, path: I, def?: D): navReturnNode<typeof root, Readonly<typeof path> | typeof path, IsStrictlyAny<D> extends true ? never : D>;
export {};
