"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseRelatedArtist = exports.parsePlaylist = exports.parseVideo = exports.parseSong = exports.parseSingle = exports.parseAlbum = exports.parseContentList = exports.Parser = void 0;
//This file is functionally complete (except for locales)
const pyLibraryMock_1 = require("../pyLibraryMock");
const index_1 = require("./index");
const songs_1 = require("./songs");
const utils_1 = require("./utils");
const i18next_1 = __importDefault(require("i18next"));
class Parser {
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    constructor() { }
    parseSearchResults(results, resultType, category) {
        const searchResults = [];
        const defaultOffset = !resultType ? 2 : 0;
        for (const result of results) {
            const data = result[index_1.MRLIR];
            let searchResult = { category: category };
            if (!resultType) {
                resultType =
                    (0, utils_1.getItemText)(data, 1)?.toLowerCase() ?? null;
                const resultTypes = [
                    'artist',
                    'playlist',
                    'song',
                    'video',
                    'station',
                ];
                const resultTypesLocal = [
                    i18next_1.default.t('artist'),
                    i18next_1.default.t('playlist'),
                    i18next_1.default.t('song'),
                    i18next_1.default.t('video'),
                    i18next_1.default.t('station'),
                ];
                // default to album since it's labeled with multiple values ('Single', 'EP', etc.)
                if (resultType && !resultTypesLocal.includes(resultType)) {
                    resultType = 'album';
                }
                else {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    resultType = resultTypes[resultTypesLocal.indexOf(resultType)];
                }
            }
            searchResult['resultType'] = resultType;
            if (resultType != 'artist') {
                searchResult['title'] = (0, utils_1.getItemText)(data, 0);
            }
            if (resultType == 'artist') {
                searchResult['artist'] = (0, utils_1.getItemText)(data, 0);
                (0, utils_1.parseMenuPlaylists)(data, searchResult);
            }
            else if (resultType == 'album') {
                searchResult['type'] = (0, utils_1.getItemText)(data, 1);
            }
            else if (resultType == 'playlist') {
                const flexItem = (0, utils_1.getFlexColumnItem)(data, 1)?.['text']['runs'];
                const hasAuthor = flexItem?.length == defaultOffset + 3;
                searchResult['itemCount'] =
                    flexItem &&
                        (0, utils_1.nav)(flexItem, [
                            defaultOffset + (hasAuthor ? 2 : 0),
                            'text',
                        ]).split(' ')[0];
                searchResult['author'] = !hasAuthor
                    ? null
                    : (0, utils_1.nav)(flexItem, [defaultOffset, 'text']);
            }
            else if (resultType == 'station') {
                searchResult['videoId'] = (0, utils_1.nav)(data, index_1.NAVIGATION_VIDEO_ID);
                searchResult['playlistId'] = (0, utils_1.nav)(data, index_1.NAVIGATION_PLAYLIST_ID);
            }
            else if (resultType == 'song') {
                searchResult['album'] = null;
                if ('menu' in data) {
                    const toggleMenu = (0, utils_1.findObjectByKey)((0, utils_1.nav)(data, index_1.MENU_ITEMS, null), //@codyduong this isn't nullable in the py library? todo discovery why...
                    index_1.TOGGLE_MENU);
                    if (toggleMenu) {
                        searchResult['feedbackTokens'] = (0, songs_1.parseSongMenuTokens)(toggleMenu);
                    }
                }
            }
            else if (resultType == 'video') {
                searchResult['views'] = null;
            }
            else if (resultType == 'upload') {
                const browseId = (0, utils_1.nav)(data, index_1.NAVIGATION_BROWSE_ID, null);
                if (!browseId) {
                    // song result
                    const flexItems = [0, 1].map((i) => (0, utils_1.nav)((0, utils_1.getFlexColumnItem)(data, i), ['text', 'runs'], null));
                    if (flexItems[0]) {
                        searchResult['videoId'] = (0, utils_1.nav)(flexItems[0][0], index_1.NAVIGATION_VIDEO_ID, null);
                        searchResult['playlistId'] = (0, utils_1.nav)(flexItems[0][0], index_1.NAVIGATION_PLAYLIST_ID, null);
                    }
                    if (flexItems[1]) {
                        searchResult = { ...searchResult, ...(0, songs_1.parseSongRuns)(flexItems[1]) };
                    }
                    searchResult['resultType'] = 'song';
                }
                else {
                    //artist or album result
                    searchResult['browseId'] = browseId;
                    if (searchResult['browseId'].includes('artist')) {
                        searchResult['resultType'] = 'artist';
                    }
                    else {
                        const flexItem2 = (0, utils_1.getFlexColumnItem)(data, 1);
                        // const runs = [
                        //     run['text'] for i, run in enumerate(flex_item2['text']['runs'])
                        //     if i % 2 == 0
                        // ]
                        const runs = flexItem2?.['text']['runs'].map((value, index) => {
                            if (index % 2 == 0) {
                                return value['text'];
                            }
                        });
                        if (runs && runs.length > 1) {
                            searchResult['artist'] = runs[1];
                        }
                        if (runs && runs.length > 2) {
                            //# date may be missing
                            searchResult['releaseDate'] = runs[2];
                        }
                        searchResult['resultType'] = 'album';
                    }
                }
            }
            if (['song', 'video'].includes(resultType)) {
                searchResult['videoId'] = (0, utils_1.nav)(data, [
                    ...index_1.PLAY_BUTTON,
                    'playNavigationEndpoint',
                    'watchEndpoint',
                    'videoId',
                ], null);
            }
            if (['song', 'video', 'album'].includes(resultType)) {
                searchResult['duration'] = null;
                searchResult['year'] = null;
                const hasOffset = resultType == 'album' || (defaultOffset && !!searchResult['videoId']);
                const flexItem = (0, utils_1.getFlexColumnItem)(data, 1);
                const runs = flexItem?.['text']['runs'].slice(hasOffset ? 2 : 0);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const songInfo = (0, songs_1.parseSongRuns)(runs);
                searchResult = { ...searchResult, ...songInfo };
            }
            if (['artist', 'album', 'playlist'].includes(resultType)) {
                searchResult['browseId'] = (0, utils_1.nav)(data, index_1.NAVIGATION_BROWSE_ID, null);
                if (!searchResult['browseId'])
                    continue;
            }
            if (['song', 'album'].includes(resultType))
                searchResult['isExplicit'] = (0, utils_1.nav)(data, index_1.BADGE_LABEL, null) != null;
            searchResult['thumbnails'] = (0, utils_1.nav)(data, index_1.THUMBNAILS, null);
            searchResults.push(searchResult);
        }
        return searchResults;
    }
    parseArtistContents(results) {
        const categories = ['albums', 'singles', 'videos', 'playlists', 'related'];
        const categories_local = [
            i18next_1.default.t('albums'),
            i18next_1.default.t('singles'),
            i18next_1.default.t('videos'),
            i18next_1.default.t('playlists'),
            i18next_1.default.t('related'),
        ];
        const categories_parser = [
            parseAlbum,
            parseSingle,
            parseVideo,
            parsePlaylist,
            parseRelatedArtist,
        ];
        const artist = {};
        categories.forEach((category, i) => {
            const data = results
                .map((r) => {
                if (r['musicCarouselShelfRenderer'] &&
                    (0, utils_1.nav)(r, [...index_1.CAROUSEL, ...index_1.CAROUSEL_TITLE])['text'].toLowerCase() ==
                        categories_local[i])
                    return r['musicCarouselShelfRenderer'];
            })
                .filter((x) => x);
            if (data[0]) {
                //@ts-expect-error: We set this later in flow
                artist[category] = { browseId: null, results: [] };
                if ('navigationEndpoint' in (0, utils_1.nav)(data[0], index_1.CAROUSEL_TITLE)) {
                    artist[category]['browseId'] = (0, utils_1.nav)(data[0], [
                        ...index_1.CAROUSEL_TITLE,
                        ...index_1.NAVIGATION_BROWSE_ID,
                    ]);
                    if (['albums', 'singles', 'playlists'].includes(category)) {
                        //@ts-expect-error: TS Control Flow Discrimination fails here :(
                        artist[category].params = (0, utils_1.nav)(data[0], index_1.CAROUSEL_TITLE)['navigationEndpoint']['browseEndpoint']['params'];
                    }
                }
                //@ts-expect-error: It tries it's best LOL.
                artist[category]['results'] = parseContentList(data[0]['contents'], categories_parser[i]);
            }
        });
        return artist;
    }
    parseHome(rows) {
        const items = [];
        for (const row of rows) {
            const contents = [];
            let results;
            if (row[index_1.CAROUSEL[0]]) {
                results = (0, utils_1.nav)(row, index_1.CAROUSEL);
            }
            else if ('musicImmersiveCarouselShelfRenderer' in row) {
                results = row['musicImmersiveCarouselShelfRenderer'];
            }
            else {
                continue;
            }
            for (const result of results['contents']) {
                let data = (0, utils_1.nav)(result, [index_1.MTRIR], null);
                let content = {};
                if (data) {
                    const page_type = (0, utils_1.nav)(data, [...index_1.TITLE, ...index_1.NAVIGATION_BROWSE, ...index_1.PAGE_TYPE], null);
                    if (!page_type) {
                        content = parseSong(data);
                    }
                    else if (page_type == 'MUSIC_PAGE_TYPE_ALBUM') {
                        content = parseAlbum(data);
                    }
                    else if (page_type == 'MUSIC_PAGE_TYPE_ARTIST') {
                        content = parseRelatedArtist(data);
                    }
                    else if (page_type == 'MUSIC_PAGE_TYPE_PLAYLIST') {
                        content = parsePlaylist(data);
                    }
                }
                else {
                    data = (0, utils_1.nav)(result, [index_1.MRLIR]);
                    const columns = [];
                    for (let i = 0; i < data['flexColumns'].length; i++) {
                        columns.push((0, utils_1.getFlexColumnItem)(data, i));
                    }
                    content = {
                        title: (0, utils_1.nav)(columns[0], index_1.TEXT_RUN_TEXT),
                        videoId: (0, utils_1.nav)(columns[0], [...index_1.TEXT_RUN, ...index_1.NAVIGATION_VIDEO_ID]),
                        thumbnails: (0, utils_1.nav)(data, index_1.THUMBNAILS),
                        ...(0, songs_1.parseSongRuns)((0, utils_1.nav)(columns[1], index_1.TEXT_RUNS)),
                    };
                    if (columns.length > 2 && columns[2]) {
                        content['album'] = {
                            title: (0, utils_1.nav)(columns[2], index_1.TEXT_RUN_TEXT),
                            browseId: (0, utils_1.nav)(columns[2], [...index_1.TEXT_RUN, ...index_1.NAVIGATION_BROWSE_ID]),
                        };
                    }
                }
                Object.keys(content).length > 0 && contents.push(content);
            }
            items.push({
                title: (0, utils_1.nav)(results, [...index_1.CAROUSEL_TITLE, 'text']),
                contents: contents,
            });
        }
        return items;
    }
}
exports.Parser = Parser;
function parseContentList(results, parse_func, key = index_1.MTRIR) {
    const contents = [];
    for (const result of results) {
        contents.push(parse_func(result[key]));
    }
    return contents;
}
exports.parseContentList = parseContentList;
function parseAlbum(result) {
    return {
        title: (0, utils_1.nav)(result, index_1.TITLE_TEXT, null),
        year: (0, utils_1.nav)(result, index_1.SUBTITLE2, null),
        browseId: (0, utils_1.nav)(result, [...index_1.TITLE, ...index_1.NAVIGATION_BROWSE_ID]),
        thumbnails: (0, utils_1.nav)(result, index_1.THUMBNAIL_RENDERER),
    };
}
exports.parseAlbum = parseAlbum;
function parseSingle(result) {
    return {
        title: (0, utils_1.nav)(result, index_1.TITLE_TEXT),
        year: (0, utils_1.nav)(result, index_1.SUBTITLE, null),
        browseId: (0, utils_1.nav)(result, [...index_1.TITLE, ...index_1.NAVIGATION_BROWSE_ID]),
        thumbnails: (0, utils_1.nav)(result, index_1.THUMBNAIL_RENDERER),
    };
}
exports.parseSingle = parseSingle;
function parseSong(result) {
    return {
        title: (0, utils_1.nav)(result, index_1.TITLE_TEXT),
        videoId: (0, utils_1.nav)(result, index_1.NAVIGATION_VIDEO_ID),
        playlistId: (0, utils_1.nav)(result, index_1.NAVIGATION_PLAYLIST_ID, null),
        thumbnails: (0, utils_1.nav)(result, index_1.THUMBNAIL_RENDERER),
        ...(0, songs_1.parseSongRuns)(result['subtitle']['runs']),
    };
}
exports.parseSong = parseSong;
function parseVideo(result) {
    const runs = result['subtitle']['runs'];
    const artistsLen = (0, utils_1.getDotSeperatorIndex)(runs);
    const video = {
        title: (0, utils_1.nav)(result, index_1.TITLE_TEXT),
        videoId: (0, utils_1.nav)(result, index_1.NAVIGATION_VIDEO_ID),
        artists: (0, songs_1.parseSongArtistsRuns)(runs.slice(0, artistsLen)),
        playlistId: (0, utils_1.nav)(result, index_1.NAVIGATION_PLAYLIST_ID, null),
        thumbnails: (0, utils_1.nav)(result, index_1.THUMBNAIL_RENDERER, null),
    };
    video['views'] = runs[runs.length - 1]['text'].split(' ')[0];
    return video;
}
exports.parseVideo = parseVideo;
function parsePlaylist(data) {
    const playlist = {
        title: (0, utils_1.nav)(data, index_1.TITLE_TEXT),
        playlistId: (0, utils_1.nav)(data, [...index_1.TITLE, ...index_1.NAVIGATION_BROWSE_ID]).slice(2),
        thumbnails: (0, utils_1.nav)(data, index_1.THUMBNAIL_RENDERER),
    };
    const subtitle = data['subtitle'];
    if ('runs' in subtitle) {
        //[run['text'] for run in subtitle['runs']]
        const runText = subtitle['runs'].map((run) => run['text']);
        playlist['description'] = runText.join('');
        if (subtitle['runs'].length == 3 &&
            pyLibraryMock_1.re.search(/\d+ /, (0, utils_1.nav)(data, index_1.SUBTITLE2))) {
            playlist['count'] = (0, utils_1.nav)(data, index_1.SUBTITLE2).split(' ')[0];
            playlist['author'] = (0, songs_1.parseSongArtistsRuns)(subtitle['runs'].slice(0, 1));
        }
    }
    return playlist;
}
exports.parsePlaylist = parsePlaylist;
function parseRelatedArtist(data) {
    let subscribers = (0, utils_1.nav)(data, index_1.SUBTITLE, null);
    if (subscribers) {
        subscribers = subscribers.split(' ')[0];
    }
    return {
        title: (0, utils_1.nav)(data, index_1.TITLE_TEXT),
        browseId: (0, utils_1.nav)(data, [...index_1.TITLE, ...index_1.NAVIGATION_BROWSE_ID]),
        subscribers: subscribers,
        thumbnails: (0, utils_1.nav)(data, index_1.THUMBNAIL_RENDERER),
    };
}
exports.parseRelatedArtist = parseRelatedArtist;
