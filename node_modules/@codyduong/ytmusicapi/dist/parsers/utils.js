"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDotSeperatorIndex = exports.findObjectByKey = exports.nav = exports.validatePlaylistId = exports.validateResponse = exports.resendRequestUntilParsedResponseIsValid = exports.getContinuationString = exports.getParsedContinuationItems = exports.getValidatedContinuations = exports.getContinuations = exports.getBrowseId = exports.getFixedColumnItem = exports.getFlexColumnItem = exports.getItemText = exports.parseMenuPlaylists = void 0;
const nav_1 = require("@codyduong/nav");
const index_1 = require("./index");
function parseMenuPlaylists(data, result) {
    // What... @CODYDUONG discovery
    // const watchMenu = findObjectByKey(
    //   nav(data, MENU_ITEMS),
    //   'menuNavigationItemRenderer'
    // );
    const watchMenu = (0, nav_1.nav)(data, index_1.MENU_ITEMS)?.['menuNavigationItemRenderer'];
    if (watchMenu) {
        for (const item of watchMenu.map((x) => x['menuNavigationItemRenderer'])) {
            const icon = (0, nav_1.nav)(item, ['icon', 'iconType']);
            let watchKey;
            if (icon == 'MUSIC_SHUFFLE') {
                watchKey = 'shuffleId';
            }
            else if (icon == 'MIX') {
                watchKey = 'radioId';
            }
            else {
                continue;
            }
            let watchId = (0, nav_1.nav)(item, ['navigationEndpoint', 'watchPlaylistEndpoint', 'playlistId'], null);
            if (!watchId) {
                watchId = (0, nav_1.nav)(item, ['navigationEndpoint', 'watchEndpoint', 'playlistId'], null);
            }
            if (watchId) {
                result[watchKey] = watchId;
            }
        }
    }
}
exports.parseMenuPlaylists = parseMenuPlaylists;
function getItemText(item, index, run_index = 0, none_if_absent = false) {
    const column = getFlexColumnItem(item, index);
    if (!column) {
        return null;
    }
    if (none_if_absent && column['text']['runs'].length < run_index + 1) {
        return null;
    }
    return column['text']['runs'][run_index]['text'];
}
exports.getItemText = getItemText;
function getFlexColumnItem(item, index) {
    if (item['flexColumns'].length <= index ||
        !('text' in
            item['flexColumns'][index]['musicResponsiveListItemFlexColumnRenderer']) ||
        !('runs' in
            item['flexColumns'][index]['musicResponsiveListItemFlexColumnRenderer']['text'])) {
        return null;
    }
    return item['flexColumns'][index]['musicResponsiveListItemFlexColumnRenderer'];
}
exports.getFlexColumnItem = getFlexColumnItem;
function getFixedColumnItem(item, index) {
    if (!item['fixedColumns'][index]['musicResponsiveListItemFixedColumnRenderer']['text'] ||
        !item['fixedColumns'][index]['musicResponsiveListItemFixedColumnRenderer']['text']['runs'])
        return null;
    return item['fixedColumns'][index]['musicResponsiveListItemFixedColumnRenderer'];
}
exports.getFixedColumnItem = getFixedColumnItem;
function getBrowseId(item, index) {
    if (!item['text']['runs'][index]['navigationEndpoint']) {
        return null;
    }
    else {
        return (0, nav_1.nav)(item['text']['runs'][index], index_1.NAVIGATION_BROWSE_ID);
    }
}
exports.getBrowseId = getBrowseId;
async function getContinuations(results, continuation_type, limit, requestFunc, parse_func, ctokenPath = '') {
    let items = [];
    while ('continuations' in results && items.length < limit) {
        const additionalParams = getContinuationParams(results, ctokenPath);
        const response = await requestFunc(additionalParams);
        if ('continuationContents' in response) {
            results = response['continuationContents'][continuation_type];
        }
        else {
            break;
        }
        const contents = getContinuationContents(results, parse_func);
        if (contents?.length == 0) {
            break;
        }
        items = items.concat(contents);
    }
    return items;
}
exports.getContinuations = getContinuations;
async function getValidatedContinuations(results, continuation_type, limit, per_page, request_func, parse_func, ctoken_path = '') {
    let items = [];
    while ('continuations' in results && items.length < limit) {
        const additionalParams = getContinuationParams(results, ctoken_path);
        const wrapped_parse_func = (rawResponse) => getParsedContinuationItems(rawResponse, parse_func, continuation_type);
        const validateFunc = (parsed) => validateResponse(parsed, per_page, limit, items.length);
        const response = await resendRequestUntilParsedResponseIsValid(request_func, additionalParams, wrapped_parse_func, validateFunc, 3);
        results = response['results'];
        items = [...items, ...response['parsed']];
    }
    return items;
}
exports.getValidatedContinuations = getValidatedContinuations;
function getParsedContinuationItems(response, parseFunc, continuationType) {
    const results = response['continuationContents'][continuationType];
    return {
        results: results,
        parsed: getContinuationContents(results, parseFunc),
    };
}
exports.getParsedContinuationItems = getParsedContinuationItems;
function getContinuationParams(results, ctoken_path) {
    const ctoken = (0, nav_1.nav)(results, [
        'continuations',
        0,
        'next' + ctoken_path + 'ContinuationData',
        'continuation',
    ]);
    return getContinuationString(ctoken);
}
function getContinuationString(ctoken) {
    return `&ctoken=${ctoken}&continuation=${ctoken}`;
}
exports.getContinuationString = getContinuationString;
function getContinuationContents(continuation, parseFunc) {
    for (const term of ['contents', 'items']) {
        if (term in continuation) {
            return parseFunc(continuation[term]);
        }
    }
    return [];
}
async function resendRequestUntilParsedResponseIsValid(requestFunc, request_additional_params, parse_func, validateFunc, max_retries) {
    const response = await requestFunc(request_additional_params);
    let parsedObject = parse_func(response);
    let retryCounter = 0;
    while (!validateFunc(parsedObject) && retryCounter < max_retries) {
        const response = requestFunc(request_additional_params);
        const attempt = parse_func(response);
        if (attempt['parsed'].length > parsedObject['parsed'].length) {
            parsedObject = attempt;
            retryCounter += 1;
        }
    }
    return parsedObject;
}
exports.resendRequestUntilParsedResponseIsValid = resendRequestUntilParsedResponseIsValid;
function validateResponse(response, perPage, limit, currentCount) {
    const remaining_items_count = limit - currentCount;
    const expected_items_count = Math.min(perPage, remaining_items_count);
    // response is invalid, if it has less items then minimal expected count
    return response['parsed'].length >= expected_items_count;
}
exports.validateResponse = validateResponse;
function validatePlaylistId(playlistId) {
    return !playlistId?.startsWith('VL')
        ? playlistId ?? null
        : playlistId.slice(2);
}
exports.validatePlaylistId = validatePlaylistId;
var nav_2 = require("@codyduong/nav");
Object.defineProperty(exports, "nav", { enumerable: true, get: function () { return nav_2.nav; } });
//These implementations are sketch...
function findObjectByKey(objectList, key, nested, isKey = false) {
    if (objectList) {
        for (let item of objectList) {
            if (nested) {
                item = item[nested];
            }
            if (key in item) {
                return isKey ? item[key] : item;
            }
        }
    }
    return null;
}
exports.findObjectByKey = findObjectByKey;
function getDotSeperatorIndex(runs) {
    let index = runs.length;
    // cheap workaround rather than deep equality
    const indexOf = runs.findIndex((v) => v['text'] == ' â€¢ ');
    if (indexOf !== -1) {
        index = indexOf;
    }
    return index;
}
exports.getDotSeperatorIndex = getDotSeperatorIndex;
